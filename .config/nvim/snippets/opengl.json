{
    "OpenGL Bootstrap (GLFW)": {
        "prefix": [
            "gl_bootstrap",
            "main_gl"
        ],
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#define GL_SILENCE_DEPRECATION",
            "#include <GLFW/glfw3.h>",
            "#include <OpenGL/gl3.h>",
            "",
            "int main(void)",
            "{",
            "    if (!glfwInit()) return -1;",
            "",
            "    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);",
            "    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);",
            "    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);",
            "    #ifdef __APPLE__",
            "        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);",
            "    #endif",
            "",
            "    GLFWwindow* window = glfwCreateWindow(800, 600, \"${1:OpenGL App}\", NULL, NULL);",
            "    if (!window) {",
            "        glfwTerminate();",
            "        return -1;",
            "    }",
            "",
            "    glfwMakeContextCurrent(window);",
            "    glfwSwapInterval(1); // Enable VSync",
            "",
            "    printf(\"OpenGL Version: %s\\\\n\", glGetString(GL_VERSION));",
            "",
            "    // Setup Resources",
            "    $0",
            "",
            "    while (!glfwWindowShouldClose(window))",
            "    {",
            "        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);",
            "        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);",
            "",
            "        // Draw",
            "",
            "        glfwSwapBuffers(window);",
            "        glfwPollEvents();",
            "    }",
            "",
            "    glfwTerminate();",
            "    return 0;",
            "}"
        ],
        "description": "OpenGL Bootstrap with GLFW for macOS"
    },
    "OpenGL Shader Program": {
        "prefix": [
            "gl_shader",
            "shader_program"
        ],
        "body": [
            "// Simple Shader Loader Helper",
            "GLuint create_shader(GLenum type, const char* source) {",
            "    GLuint shader = glCreateShader(type);",
            "    glShaderSource(shader, 1, &source, NULL);",
            "    glCompileShader(shader);",
            "    int success;",
            "    char infoLog[512];",
            "    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);",
            "    if (!success) {",
            "        glGetShaderInfoLog(shader, 512, NULL, infoLog);",
            "        printf(\"ERROR::SHADER::COMPILATION_FAILED\\\\n%s\\\\n\", infoLog);",
            "    }",
            "    return shader;",
            "}",
            "",
            "GLuint create_program(const char* vertexSource, const char* fragmentSource) {",
            "    GLuint vertexShader = create_shader(GL_VERTEX_SHADER, vertexSource);",
            "    GLuint fragmentShader = create_shader(GL_FRAGMENT_SHADER, fragmentSource);",
            "",
            "    GLuint program = glCreateProgram();",
            "    glAttachShader(program, vertexShader);",
            "    glAttachShader(program, fragmentShader);",
            "    glLinkProgram(program);",
            "",
            "    int success;",
            "    char infoLog[512];",
            "    glGetProgramiv(program, GL_LINK_STATUS, &success);",
            "    if (!success) {",
            "        glGetProgramInfoLog(program, 512, NULL, infoLog);",
            "        printf(\"ERROR::PROGRAM::LINKING_FAILED\\\\n%s\\\\n\", infoLog);",
            "    }",
            "",
            "    glDeleteShader(vertexShader);",
            "    glDeleteShader(fragmentShader);",
            "",
            "    return program;",
            "}"
        ],
        "description": "OpenGL shader compilation and linking helpers"
    },
    "OpenGL VAO/VBO Setup": {
        "prefix": [
            "gl_vao",
            "vao_vbo"
        ],
        "body": [
            "// Vertex Data",
            "float vertices[] = {",
            "    // positions        // colors",
            "    -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,",
            "     0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,",
            "     0.0f,  0.5f, 0.0f, 0.0f, 0.0f, 1.0f",
            "};",
            "",
            "GLuint VAO, VBO;",
            "glGenVertexArrays(1, &VAO);",
            "glGenBuffers(1, &VBO);",
            "",
            "glBindVertexArray(VAO);",
            "glBindBuffer(GL_ARRAY_BUFFER, VBO);",
            "glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);",
            "",
            "// Position attribute",
            "glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);",
            "glEnableVertexAttribArray(0);",
            "",
            "// Color attribute",
            "glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));",
            "glEnableVertexAttribArray(1);",
            "",
            "glBindVertexArray(0); // Unbind"
        ],
        "description": "OpenGL VAO/VBO setup with interleaved attributes"
    },
    "OpenGL Texture Loading": {
        "prefix": [
            "gl_texture",
            "texture2d"
        ],
        "body": [
            "GLuint texture;",
            "glGenTextures(1, &texture);",
            "glBindTexture(GL_TEXTURE_2D, texture);",
            "",
            "// Set texture wrapping/filtering options",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);",
            "",
            "// Load image data (using stb_image or similar)",
            "int width, height, nrChannels;",
            "unsigned char *data = stbi_load(\"${1:texture.jpg}\", &width, &height, &nrChannels, 0);",
            "if (data) {",
            "    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);",
            "    glGenerateMipmap(GL_TEXTURE_2D);",
            "} else {",
            "    printf(\"Failed to load texture\\\\n\");",
            "}",
            "stbi_image_free(data);"
        ],
        "description": "OpenGL 2D texture loading with mipmaps"
    },
    "OpenGL Uniform": {
        "prefix": [
            "gl_uniform",
            "uniform"
        ],
        "body": [
            "GLint ${1:uniformName}_loc = glGetUniformLocation(shaderProgram, \"${1:uniformName}\");",
            "glUniform${2|1f,2f,3f,4f,1i,Matrix4fv|}(${1}_loc, ${3:value});"
        ],
        "description": "OpenGL uniform variable setup"
    },
    "OpenGL EBO/Index Buffer": {
        "prefix": [
            "gl_ebo",
            "index_buffer"
        ],
        "body": [
            "unsigned int indices[] = {",
            "    0, 1, 2,  // First triangle",
            "    2, 3, 0   // Second triangle",
            "};",
            "",
            "GLuint EBO;",
            "glGenBuffers(1, &EBO);",
            "glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);",
            "glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);",
            "",
            "// Draw with indices:",
            " glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);"
        ],
        "description": "OpenGL Element Buffer Object (indexed drawing)"
    },
    "OpenGL Framebuffer (FBO)": {
        "prefix": [
            "gl_fbo",
            "framebuffer"
        ],
        "body": [
            "// Create framebuffer",
            "GLuint fbo;",
            "glGenFramebuffers(1, &fbo);",
            "glBindFramebuffer(GL_FRAMEBUFFER, fbo);",
            "",
            "// Create texture attachment",
            "GLuint textureColorbuffer;",
            "glGenTextures(1, &textureColorbuffer);",
            "glBindTexture(GL_TEXTURE_2D, textureColorbuffer);",
            "glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, ${1:800}, ${2:600}, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);",
            "glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);",
            "glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0);",
            "",
            "// Create renderbuffer for depth/stencil",
            "GLuint rbo;",
            "glGenRenderbuffers(1, &rbo);",
            "glBindRenderbuffer(GL_RENDERBUFFER, rbo);",
            "glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, ${1}, ${2});",
            "glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);",
            "",
            "if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)",
            "    printf(\"ERROR: Framebuffer is not complete!\\\\n\");",
            "",
            "glBindFramebuffer(GL_FRAMEBUFFER, 0); // Back to default"
        ],
        "description": "OpenGL Framebuffer Object for offscreen rendering"
    },
    "GLSL Vertex Shader": {
        "prefix": [
            "glsl_vertex",
            "vertex_shader_glsl"
        ],
        "body": [
            "#version 410 core",
            "",
            "layout (location = 0) in vec3 aPos;",
            "layout (location = 1) in vec3 aColor;",
            "layout (location = 2) in vec2 aTexCoord;",
            "",
            "out vec3 ourColor;",
            "out vec2 TexCoord;",
            "",
            "uniform mat4 model;",
            "uniform mat4 view;",
            "uniform mat4 projection;",
            "",
            "void main()",
            "{",
            "    gl_Position = projection * view * model * vec4(aPos, 1.0);",
            "    ourColor = aColor;",
            "    TexCoord = aTexCoord;",
            "}"
        ],
        "description": "Complete GLSL vertex shader with MVP matrices"
    },
    "GLSL Fragment Shader": {
        "prefix": [
            "glsl_fragment",
            "fragment_shader_glsl"
        ],
        "body": [
            "#version 410 core",
            "",
            "in vec3 ourColor;",
            "in vec2 TexCoord;",
            "",
            "out vec4 FragColor;",
            "",
            "uniform sampler2D texture1;",
            "",
            "void main()",
            "{",
            "    FragColor = texture(texture1, TexCoord) * vec4(ourColor, 1.0);",
            "}"
        ],
        "description": "Complete GLSL fragment shader with texture sampling"
    },
    "OpenGL View Matrix (Camera)": {
        "prefix": [
            "gl_view",
            "camera_matrix"
        ],
        "body": [
            "// Camera setup (using GLM)",
            "glm::vec3 cameraPos   = glm::vec3(${1:0.0f, 0.0f, 3.0f});",
            "glm::vec3 cameraTarget = glm::vec3(${2:0.0f, 0.0f, 0.0f});",
            "glm::vec3 cameraUp    = glm::vec3(${3:0.0f, 1.0f, 0.0f});",
            "",
            "glm::mat4 view = glm::lookAt(cameraPos, cameraTarget, cameraUp);",
            "glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));"
        ],
        "description": "OpenGL view/camera matrix with GLM"
    },
    "OpenGL Projection Matrix": {
        "prefix": [
            "gl_projection",
            "projection_matrix"
        ],
        "body": [
            "// Perspective projection",
            "glm::mat4 projection = glm::perspective(",
            "    glm::radians(${1:45.0f}),  // FOV",
            "    ${2:800.0f} / ${3:600.0f}, // Aspect ratio",
            "    ${4:0.1f},                  // Near plane",
            "    ${5:100.0f}                 // Far plane",
            ");",
            "glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));"
        ],
        "description": "OpenGL perspective projection matrix"
    },
    "OpenGL Model Matrix": {
        "prefix": [
            "gl_model",
            "model_transform"
        ],
        "body": [
            "glm::mat4 model = glm::mat4(1.0f);",
            "model = glm::translate(model, glm::vec3(${1:0.0f, 0.0f, 0.0f}));",
            "model = glm::rotate(model, glm::radians(${2:45.0f}), glm::vec3(${3:0.0f, 1.0f, 0.0f}));",
            "model = glm::scale(model, glm::vec3(${4:1.0f, 1.0f, 1.0f}));",
            "glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));"
        ],
        "description": "OpenGL model transformation matrix"
    }
}