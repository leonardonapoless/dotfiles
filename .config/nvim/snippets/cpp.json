{
    "C++ Main": {
        "prefix": [
            "main",
            "main_cpp"
        ],
        "body": [
            "#include <iostream>",
            "",
            "int main(int argc, char* argv[])",
            "{",
            "    $0",
            "    return 0;",
            "}"
        ],
        "description": "Basic C++ main function"
    },
    "C++ Class": {
        "prefix": [
            "class",
            "cpp_class"
        ],
        "body": [
            "class ${1:ClassName}",
            "{",
            "public:",
            "    ${1}();",
            "    ~${1}();",
            "",
            "    $0",
            "",
            "private:",
            "};"
        ],
        "description": "C++ class template"
    },
    "C++ Header Guard": {
        "prefix": [
            "header",
            "hpp"
        ],
        "body": [
            "#ifndef ${1:HEADER_NAME}_H",
            "#define ${1}_H",
            "",
            "$0",
            "",
            "#endif // ${1}_H"
        ],
        "description": "C++ header guard"
    },
    "C++ Namespace": {
        "prefix": [
            "namespace",
            "ns"
        ],
        "body": [
            "namespace ${1:name}",
            "{",
            "    $0",
            "} // namespace ${1}"
        ],
        "description": "C++ namespace"
    },
    "C++ For Loop": {
        "prefix": [
            "for",
            "fori"
        ],
        "body": [
            "for (size_t ${1:i} = 0; ${1} < ${2:count}; ++${1})",
            "{",
            "    $0",
            "}"
        ],
        "description": "C++ for loop"
    },
    "C++ Range-based For": {
        "prefix": [
            "forr",
            "foreach"
        ],
        "body": [
            "for (auto& ${1:item} : ${2:container})",
            "{",
            "    $0",
            "}"
        ],
        "description": "C++ range-based for loop"
    },
    "C++ Unique Ptr": {
        "prefix": [
            "unique",
            "unique_ptr"
        ],
        "body": "auto ${1:ptr} = std::make_unique<${2:Type}>(${3:args});",
        "description": "std::unique_ptr"
    },
    "C++ Shared Ptr": {
        "prefix": [
            "shared",
            "shared_ptr"
        ],
        "body": "auto ${1:ptr} = std::make_shared<${2:Type}>(${3:args});",
        "description": "std::shared_ptr"
    },
    "C++ Vector": {
        "prefix": [
            "vector",
            "vec"
        ],
        "body": "std::vector<${1:Type}> ${2:name};",
        "description": "std::vector"
    },
    "C++ Map": {
        "prefix": [
            "map",
            "std_map"
        ],
        "body": "std::map<${1:KeyType}, ${2:ValueType}> ${3:name};",
        "description": "std::map"
    },
    "C++ Unordered Map": {
        "prefix": [
            "unordered_map",
            "umap"
        ],
        "body": "std::unordered_map<${1:KeyType}, ${2:ValueType}> ${3:name};",
        "description": "std::unordered_map"
    },
    "C++ Lambda": {
        "prefix": [
            "lambda",
            "lam"
        ],
        "body": [
            "auto ${1:lambda} = [${2:&}](${3:params}) ${4:-> auto} {",
            "    $0",
            "};"
        ],
        "description": "C++ lambda function"
    },
    "C++ Try-Catch": {
        "prefix": [
            "try",
            "trycatch"
        ],
        "body": [
            "try",
            "{",
            "    $0",
            "}",
            "catch (const ${1:std::exception}& e)",
            "{",
            "    std::cerr << \"Error: \" << e.what() << std::endl;",
            "}"
        ],
        "description": "C++ try-catch block"
    },
    "C++ Template Function": {
        "prefix": [
            "template",
            "tfunc"
        ],
        "body": [
            "template<typename ${1:T}>",
            "${2:void} ${3:functionName}(${4:const ${1}& arg})",
            "{",
            "    $0",
            "}"
        ],
        "description": "C++ template function"
    },
    "C++ Template Class": {
        "prefix": [
            "tclass",
            "template_class"
        ],
        "body": [
            "template<typename ${1:T}>",
            "class ${2:ClassName}",
            "{",
            "public:",
            "    ${2}();",
            "    ~${2}();",
            "",
            "    $0",
            "",
            "private:",
            "    ${1} data_;",
            "};"
        ],
        "description": "C++ template class"
    },
    "C++ Enum Class": {
        "prefix": [
            "enum",
            "enum_class"
        ],
        "body": [
            "enum class ${1:Name}",
            "{",
            "    ${2:Value1},",
            "    ${3:Value2},",
            "    $0",
            "};"
        ],
        "description": "C++ enum class"
    },
    "C++ Struct": {
        "prefix": [
            "struct",
            "cpp_struct"
        ],
        "body": [
            "struct ${1:Name}",
            "{",
            "    ${2:int} ${3:member};",
            "    $0",
            "};"
        ],
        "description": "C++ struct"
    },
    "C++ Cout": {
        "prefix": [
            "cout",
            "print"
        ],
        "body": "std::cout << ${1:\"message\"} << std::endl;",
        "description": "std::cout statement"
    },
    "C++ Cerr": {
        "prefix": [
            "cerr",
            "error"
        ],
        "body": "std::cerr << ${1:\"error\"} << std::endl;",
        "description": "std::cerr statement"
    },
    "C++ Static Assert": {
        "prefix": [
            "static_assert",
            "sassert"
        ],
        "body": "static_assert(${1:condition}, \"${2:message}\");",
        "description": "static_assert"
    },
    "C++ std::move": {
        "prefix": [
            "move",
            "std_move"
        ],
        "body": "std::move(${1:object})",
        "description": "std::move"
    },
    "C++ std::forward": {
        "prefix": [
            "forward",
            "std_forward"
        ],
        "body": "std::forward<${1:T}>(${2:arg})",
        "description": "std::forward for perfect forwarding"
    },
    "C++ Chrono Timer": {
        "prefix": [
            "timer",
            "chrono"
        ],
        "body": [
            "auto ${1:start} = std::chrono::high_resolution_clock::now();",
            "$0",
            "auto ${2:end} = std::chrono::high_resolution_clock::now();",
            "auto ${3:duration} = std::chrono::duration_cast<std::chrono::milliseconds>(${2} - ${1});",
            "std::cout << \"Elapsed: \" << ${3}.count() << \"ms\" << std::endl;"
        ],
        "description": "C++ chrono timer for benchmarking"
    },
    "C++ Algorithm Find": {
        "prefix": [
            "find",
            "std_find"
        ],
        "body": "auto ${1:it} = std::find(${2:container}.begin(), ${2}.end(), ${3:value});",
        "description": "std::find algorithm"
    },
    "C++ Algorithm Sort": {
        "prefix": [
            "sort",
            "std_sort"
        ],
        "body": "std::sort(${1:container}.begin(), ${1}.end());",
        "description": "std::sort algorithm"
    },
    "C++ File Stream Read": {
        "prefix": [
            "ifstream",
            "file_read"
        ],
        "body": [
            "std::ifstream ${1:file}(\"${2:filename}\");",
            "if (!${1}.is_open())",
            "{",
            "    std::cerr << \"Failed to open file\" << std::endl;",
            "    return;",
            "}",
            "",
            "std::string ${3:line};",
            "while (std::getline(${1}, ${3}))",
            "{",
            "    $0",
            "}",
            "${1}.close();"
        ],
        "description": "File reading with ifstream"
    },
    "C++ File Stream Write": {
        "prefix": [
            "ofstream",
            "file_write"
        ],
        "body": [
            "std::ofstream ${1:file}(\"${2:filename}\");",
            "if (!${1}.is_open())",
            "{",
            "    std::cerr << \"Failed to open file\" << std::endl;",
            "    return;",
            "}",
            "",
            "${1} << ${3:\"data\"} << std::endl;",
            "${1}.close();"
        ],
        "description": "File writing with ofstream"
    },
    "C++ std::optional": {
        "prefix": [
            "optional",
            "std_optional"
        ],
        "body": [
            "std::optional<${1:Type}> ${2:name};",
            "if (${2}.has_value())",
            "{",
            "    auto ${3:value} = ${2}.value();",
            "    $0",
            "}"
        ],
        "description": "std::optional (C++17)"
    },
    "C++ std::variant": {
        "prefix": [
            "variant",
            "std_variant"
        ],
        "body": [
            "std::variant<${1:Type1}, ${2:Type2}> ${3:name};",
            "std::visit([](auto&& arg) {",
            "    $0",
            "}, ${3});"
        ],
        "description": "std::variant with visitor (C++17)"
    },
    "C++ std::string_view": {
        "prefix": [
            "string_view",
            "sv"
        ],
        "body": "std::string_view ${1:name}${2: = \"${3:text}\"};",
        "description": "std::string_view (C++17)"
    },
    "C++ std::array": {
        "prefix": [
            "array",
            "std_array"
        ],
        "body": "std::array<${1:Type}, ${2:Size}> ${3:name};",
        "description": "std::array"
    },
    "C++ std::set": {
        "prefix": [
            "set",
            "std_set"
        ],
        "body": "std::set<${1:Type}> ${2:name};",
        "description": "std::set"
    },
    "C++ std::unordered_set": {
        "prefix": [
            "unordered_set",
            "uset"
        ],
        "body": "std::unordered_set<${1:Type}> ${2:name};",
        "description": "std::unordered_set"
    },
    "C++ std::queue": {
        "prefix": [
            "queue",
            "std_queue"
        ],
        "body": "std::queue<${1:Type}> ${2:name};",
        "description": "std::queue"
    },
    "C++ std::stack": {
        "prefix": [
            "stack",
            "std_stack"
        ],
        "body": "std::stack<${1:Type}> ${2:name};",
        "description": "std::stack"
    },
    "C++ std::deque": {
        "prefix": [
            "deque",
            "std_deque"
        ],
        "body": "std::deque<${1:Type}> ${2:name};",
        "description": "std::deque"
    },
    "C++ std::tuple": {
        "prefix": [
            "tuple",
            "std_tuple"
        ],
        "body": [
            "auto ${1:tuple} = std::make_tuple(${2:args});",
            "auto [${3:a}, ${4:b}] = ${1}; // Structured binding"
        ],
        "description": "std::tuple with structured binding"
    },
    "C++ std::pair": {
        "prefix": [
            "pair",
            "std_pair"
        ],
        "body": "auto ${1:pair} = std::make_pair(${2:first}, ${3:second});",
        "description": "std::pair"
    },
    "C++ Rule of 5": {
        "prefix": [
            "rule5",
            "rule_of_5"
        ],
        "body": [
            "class ${1:ClassName}",
            "{",
            "public:",
            "    ${1}();                                    // Constructor",
            "    ~${1}();                                   // Destructor",
            "    ${1}(const ${1}& other);                  // Copy constructor",
            "    ${1}& operator=(const ${1}& other);       // Copy assignment",
            "    ${1}(${1}&& other) noexcept;              // Move constructor",
            "    ${1}& operator=(${1}&& other) noexcept;   // Move assignment",
            "",
            "    $0",
            "",
            "private:",
            "};"
        ],
        "description": "Rule of 5 (C++11)"
    },
    "C++ RAII Wrapper": {
        "prefix": [
            "raii",
            "raii_wrapper"
        ],
        "body": [
            "class ${1:ResourceWrapper}",
            "{",
            "public:",
            "    explicit ${1}(${2:ResourceType}* resource) : resource_(resource) {}",
            "    ",
            "    ~${1}()",
            "    {",
            "        if (resource_)",
            "        {",
            "            ${3:cleanup}(resource_);",
            "        }",
            "    }",
            "",
            "    // Delete copy",
            "    ${1}(const ${1}&) = delete;",
            "    ${1}& operator=(const ${1}&) = delete;",
            "",
            "    // Allow move",
            "    ${1}(${1}&& other) noexcept : resource_(other.resource_)",
            "    {",
            "        other.resource_ = nullptr;",
            "    }",
            "",
            "    ${2}* get() const { return resource_; }",
            "",
            "private:",
            "    ${2}* resource_;",
            "};"
        ],
        "description": "RAII resource wrapper"
    },
    "C++ std::thread": {
        "prefix": [
            "thread",
            "std_thread"
        ],
        "body": [
            "std::thread ${1:worker}([${2:this}]() {",
            "    $0",
            "});",
            "${1}.join(); // or ${1}.detach();"
        ],
        "description": "std::thread"
    },
    "C++ std::mutex": {
        "prefix": [
            "mutex",
            "std_mutex"
        ],
        "body": [
            "std::mutex ${1:mtx};",
            "std::lock_guard<std::mutex> ${2:lock}(${1});",
            "$0"
        ],
        "description": "std::mutex with lock_guard"
    },
    "C++ std::unique_lock": {
        "prefix": [
            "unique_lock",
            "ulock"
        ],
        "body": [
            "std::unique_lock<std::mutex> ${1:lock}(${2:mutex});",
            "$0",
            "${1}.unlock(); // Optional manual unlock"
        ],
        "description": "std::unique_lock for flexible locking"
    },
    "C++ std::atomic": {
        "prefix": [
            "atomic",
            "std_atomic"
        ],
        "body": "std::atomic<${1:int}> ${2:counter}{${3:0}};",
        "description": "std::atomic"
    },
    "C++ std::condition_variable": {
        "prefix": [
            "condition_variable",
            "cv"
        ],
        "body": [
            "std::condition_variable ${1:cv};",
            "std::mutex ${2:mtx};",
            "",
            "// Wait:",
            "std::unique_lock<std::mutex> ${3:lock}(${2});",
            "${1}.wait(${3}, []{ return ${4:condition}; });",
            "",
            "// Notify:",
            "${1}.notify_one(); // or ${1}.notify_all();"
        ],
        "description": "std::condition_variable"
    },
    "C++ constexpr Function": {
        "prefix": [
            "constexpr",
            "constexpr_func"
        ],
        "body": [
            "constexpr ${1:int} ${2:functionName}(${3:int value})",
            "{",
            "    return ${4:value * 2};",
            "}"
        ],
        "description": "constexpr function"
    },
    "C++ Operator Overload": {
        "prefix": [
            "operator",
            "op_overload"
        ],
        "body": [
            "${1:ClassName}& operator${2:+}(const ${1}& other)",
            "{",
            "    $0",
            "    return *this;",
            "}"
        ],
        "description": "Operator overloading"
    },
    "C++ std::span": {
        "prefix": [
            "span",
            "std_span"
        ],
        "body": "std::span<${1:Type}> ${2:view}(${3:container});",
        "description": "std::span (C++20)"
    },
    "C++ Concept": {
        "prefix": [
            "concept",
            "cpp_concept"
        ],
        "body": [
            "template<typename ${1:T}>",
            "concept ${2:ConceptName} = requires(${1} ${3:t})",
            "{",
            "    { ${3}.${4:method}() } -> std::${5:convertible_to}<${6:ReturnType}>;",
            "};"
        ],
        "description": "C++20 concept"
    },
    "C++ Perfect Forwarding Constructor": {
        "prefix": [
            "forward_ctor",
            "perfect_forward"
        ],
        "body": [
            "template<typename... Args>",
            "explicit ${1:ClassName}(Args&&... args)",
            "    : ${2:member}(std::forward<Args>(args)...)",
            "{",
            "    $0",
            "}"
        ],
        "description": "Perfect forwarding constructor"
    },
    "C++ Variadic Template": {
        "prefix": [
            "variadic",
            "variadic_template"
        ],
        "body": [
            "template<typename... Args>",
            "void ${1:functionName}(Args&&... args)",
            "{",
            "    (${2:process}(std::forward<Args>(args)), ...); // Fold expression",
            "}"
        ],
        "description": "Variadic template with fold expression"
    },
    "C++ std::transform": {
        "prefix": [
            "transform",
            "std_transform"
        ],
        "body": [
            "std::transform(${1:input}.begin(), ${1}.end(), ${2:output}.begin(),",
            "    [](const auto& ${3:elem}) {",
            "        return ${4:elem * 2};",
            "    });"
        ],
        "description": "std::transform algorithm"
    },
    "C++ std::accumulate": {
        "prefix": [
            "accumulate",
            "std_accumulate"
        ],
        "body": "auto ${1:sum} = std::accumulate(${2:container}.begin(), ${2}.end(), ${3:0});",
        "description": "std::accumulate algorithm"
    },
    "C++ std::copy_if": {
        "prefix": [
            "copy_if",
            "std_copy_if"
        ],
        "body": [
            "std::copy_if(${1:input}.begin(), ${1}.end(), std::back_inserter(${2:output}),",
            "    [](const auto& ${3:elem}) {",
            "        return ${4:elem > 0};",
            "    });"
        ],
        "description": "std::copy_if algorithm"
    },
    "C++ std::remove_if": {
        "prefix": [
            "remove_if",
            "std_remove_if"
        ],
        "body": [
            "${1:container}.erase(",
            "    std::remove_if(${1}.begin(), ${1}.end(),",
            "        [](const auto& ${2:elem}) { return ${3:condition}; }),",
            "    ${1}.end());"
        ],
        "description": "Erase-remove idiom"
    },
    "C++ std::any_of": {
        "prefix": [
            "any_of",
            "std_any_of"
        ],
        "body": [
            "bool ${1:result} = std::any_of(${2:container}.begin(), ${2}.end(),",
            "    [](const auto& ${3:elem}) { return ${4:condition}; });"
        ],
        "description": "std::any_of algorithm"
    },
    "C++ std::all_of": {
        "prefix": [
            "all_of",
            "std_all_of"
        ],
        "body": [
            "bool ${1:result} = std::all_of(${2:container}.begin(), ${2}.end(),",
            "    [](const auto& ${3:elem}) { return ${4:condition}; });"
        ],
        "description": "std::all_of algorithm"
    },
    "C++ Virtual Override": {
        "prefix": [
            "override",
            "virtual_override"
        ],
        "body": "virtual ${1:void} ${2:functionName}(${3:params}) override;",
        "description": "Virtual function override"
    },
    "C++ Pure Virtual": {
        "prefix": [
            "pure_virtual",
            "abstract"
        ],
        "body": "virtual ${1:void} ${2:functionName}(${3:params}) = 0;",
        "description": "Pure virtual function (abstract)"
    },
    "C++ noexcept": {
        "prefix": [
            "noexcept",
            "nothrow"
        ],
        "body": "${1:void} ${2:functionName}(${3:params}) noexcept;",
        "description": "noexcept function"
    },
    "C++ Singleton Pattern": {
        "prefix": [
            "singleton",
            "singleton_pattern"
        ],
        "body": [
            "class ${1:Singleton}",
            "{",
            "public:",
            "    static ${1}& getInstance()",
            "    {",
            "        static ${1} instance;",
            "        return instance;",
            "    }",
            "",
            "    // Delete copy/move",
            "    ${1}(const ${1}&) = delete;",
            "    ${1}& operator=(const ${1}&) = delete;",
            "    ${1}(${1}&&) = delete;  ",
            "    ${1}& operator=(${1}&&) = delete;",
            "",
            "    $0",
            "",
            "private:",
            "    ${1}() = default;",
            "    ~${1}() = default;",
            "};"
        ],
        "description": "Thread-safe Singleton pattern"
    },
    "C++ std::async": {
        "prefix": [
            "async",
            "std_async"
        ],
        "body": [
            "auto ${1:future} = std::async(std::launch::async, [${2:this}]() {",
            "    $0",
            "    return ${3:result};",
            "});",
            "auto ${4:value} = ${1}.get();"
        ],
        "description": "std::async for asynchronous execution"
    },
    "C++ String Format (C++20)": {
        "prefix": [
            "format",
            "std_format"
        ],
        "body": "auto ${1:str} = std::format(\"${2:Format: {}}\", ${3:value});",
        "description": "std::format (C++20)"
    }
}