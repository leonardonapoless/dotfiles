{
    "Metal Bootstrap (Obj-C++)": {
        "prefix": [
            "mtl_bootstrap",
            "main_mtl"
        ],
        "body": [
            "#import <Metal/Metal.h>",
            "#import <MetalKit/MetalKit.h>",
            "#import <Cocoa/Cocoa.h>",
            "",
            "// Very minimal Metal setup",
            "int main(int argc, const char * argv[]) {",
            "    @autoreleasepool {",
            "        id<MTLDevice> device = MTLCreateSystemDefaultDevice();",
            "        if (!device) {",
            "            NSLog(@\"Metal is not supported on this device\");",
            "            return -1;",
            "        }",
            "        NSLog(@\"Selected device: %@\", [device name]);",
            "",
            "        $0",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Minimal Metal Bootstrap"
    },
    "Metal Render Pipeline": {
        "prefix": [
            "mtl_pipeline",
            "render_pipeline"
        ],
        "body": [
            "id<MTLLibrary> library = [device newDefaultLibrary];",
            "id<MTLFunction> vertexFunction = [library newFunctionWithName:@\"${1:vertexShader}\"];",
            "id<MTLFunction> fragmentFunction = [library newFunctionWithName:@\"${2:fragmentShader}\"];",
            "",
            "MTLRenderPipelineDescriptor *pipelineDescriptor = [[MTLRenderPipelineDescriptor alloc] init];",
            "pipelineDescriptor.vertexFunction = vertexFunction;",
            "pipelineDescriptor.fragmentFunction = fragmentFunction;",
            "pipelineDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;",
            "",
            "NSError *error = nil;",
            "id<MTLRenderPipelineState> pipelineState = [device newRenderPipelineStateWithDescriptor:pipelineDescriptor error:&error];",
            "if (!pipelineState) {",
            "    NSLog(@\"Failed to create pipeline state: %@\", error);",
            "}"
        ],
        "description": "Metal render pipeline state creation"
    },
    "Metal Command Buffer": {
        "prefix": [
            "mtl_command",
            "command_buffer"
        ],
        "body": [
            "id<MTLCommandQueue> commandQueue = [device newCommandQueue];",
            "id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];",
            "",
            "MTLRenderPassDescriptor *renderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor];",
            "renderPassDescriptor.colorAttachments[0].texture = ${1:currentTexture};",
            "renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;",
            "renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0);",
            "renderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;",
            "",
            "id<MTLRenderCommandEncoder> encoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];",
            "[encoder setRenderPipelineState:${2:pipelineState}];",
            "$0",
            "[encoder endEncoding];",
            "",
            "[commandBuffer presentDrawable:${3:drawable}];",
            "[commandBuffer commit];"
        ],
        "description": "Metal command buffer and render encoder"
    },
    "Metal Vertex Buffer": {
        "prefix": [
            "mtl_vertex",
            "vertex_buffer"
        ],
        "body": [
            "typedef struct {",
            "    vector_float2 position;",
            "    vector_float4 color;",
            "} Vertex;",
            "",
            "static const Vertex vertices[] = {",
            "    { {  0.0,  0.5 }, { 1, 0, 0, 1 } },",
            "    { { -0.5, -0.5 }, { 0, 1, 0, 1 } },",
            "    { {  0.5, -0.5 }, { 0, 0, 1, 1 } },",
            "};",
            "",
            "id<MTLBuffer> vertexBuffer = [device newBufferWithBytes:vertices",
            "                                                  length:sizeof(vertices)",
            "                                                 options:MTLResourceStorageModeShared];",
            "",
            "// In render encoder:",
            "[encoder setVertexBuffer:vertexBuffer offset:0 atIndex:0];",
            "[encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3];"
        ],
        "description": "Metal vertex buffer creation and drawing"
    },
    "Metal Compute Shader": {
        "prefix": [
            "mtl_compute",
            "compute_shader"
        ],
        "body": [
            "id<MTLLibrary> library = [device newDefaultLibrary];",
            "id<MTLFunction> computeFunction = [library newFunctionWithName:@\"${1:computeKernel}\"];",
            "",
            "NSError *error = nil;",
            "id<MTLComputePipelineState> computePipeline = [device newComputePipelineStateWithFunction:computeFunction error:&error];",
            "",
            "id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];",
            "id<MTLComputeCommandEncoder> encoder = [commandBuffer computeCommandEncoder];",
            "",
            "[encoder setComputePipelineState:computePipeline];",
            "[encoder setBuffer:${2:inputBuffer} offset:0 atIndex:0];",
            "[encoder setBuffer:${3:outputBuffer} offset:0 atIndex:1];",
            "",
            "MTLSize gridSize = MTLSizeMake(${4:1024}, 1, 1);",
            "NSUInteger threadGroupSize = computePipeline.maxTotalThreadsPerThreadgroup;",
            "if (threadGroupSize > ${4}) threadGroupSize = ${4};",
            "MTLSize threadgroupSize = MTLSizeMake(threadGroupSize, 1, 1);",
            "",
            "[encoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize];",
            "[encoder endEncoding];",
            "[commandBuffer commit];"
        ],
        "description": "Metal compute pipeline and dispatch"
    },
    "MSL Vertex Shader": {
        "prefix": [
            "msl_vertex",
            "vertex_shader_msl"
        ],
        "body": [
            "struct VertexIn {",
            "    float2 position [[attribute(0)]];",
            "    float4 color [[attribute(1)]];",
            "};",
            "",
            "struct VertexOut {",
            "    float4 position [[position]];",
            "    float4 color;",
            "};",
            "",
            "vertex VertexOut ${1:vertexShader}(VertexIn in [[stage_in]]) {",
            "    VertexOut out;",
            "    out.position = float4(in.position, 0.0, 1.0);",
            "    out.color = in.color;",
            "    return out;",
            "}"
        ],
        "description": "Metal Shading Language vertex shader"
    },
    "MSL Fragment Shader": {
        "prefix": [
            "msl_fragment",
            "fragment_shader_msl"
        ],
        "body": [
            "struct FragmentIn {",
            "    float4 position [[position]];",
            "    float4 color;",
            "};",
            "",
            "fragment float4 ${1:fragmentShader}(FragmentIn in [[stage_in]]) {",
            "    return in.color;",
            "}"
        ],
        "description": "Metal Shading Language fragment shader"
    },
    "Metal Texture": {
        "prefix": [
            "mtl_texture",
            "texture_metal"
        ],
        "body": [
            "MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];",
            "textureDescriptor.pixelFormat = MTLPixelFormat${1:RGBA8Unorm};",
            "textureDescriptor.width = ${2:1024};",
            "textureDescriptor.height = ${3:1024};",
            "textureDescriptor.usage = MTLTextureUsage${4:ShaderRead} | MTLTextureUsage${5:RenderTarget};",
            "",
            "id<MTLTexture> texture = [device newTextureWithDescriptor:textureDescriptor];",
            "[encoder setFragmentTexture:texture atIndex:${6:0}];"
        ],
        "description": "Metal texture creation and binding"
    },
    "Metal Depth/Stencil State": {
        "prefix": [
            "mtl_depth",
            "depth_stencil"
        ],
        "body": [
            "MTLDepthStencilDescriptor *depthDescriptor = [[MTLDepthStencilDescriptor alloc] init];",
            "depthDescriptor.depthCompareFunction = MTLCompareFunctionLess;",
            "depthDescriptor.depthWriteEnabled = YES;",
            "",
            "id<MTLDepthStencilState> depthState = [device newDepthStencilStateWithDescriptor:depthDescriptor];",
            "[encoder setDepthStencilState:depthState];"
        ],
        "description": "Metal depth and stencil state"
    },
    "Metal Blend State": {
        "prefix": [
            "mtl_blend",
            "blend_state"
        ],
        "body": [
            "pipelineDescriptor.colorAttachments[0].blendingEnabled = YES;",
            "pipelineDescriptor.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;",
            "pipelineDescriptor.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;",
            "pipelineDescriptor.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactor${1:SourceAlpha};",
            "pipelineDescriptor.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactor${2:One};",
            "pipelineDescriptor.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactor${3:OneMinusSourceAlpha};",
            "pipelineDescriptor.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactor${4:Zero};"
        ],
        "description": "Metal blending configuration"
    },
    "Metal MSAA": {
        "prefix": [
            "mtl_msaa",
            "multisample"
        ],
        "body": [
            "// Enable MSAA",
            "pipelineDescriptor.sampleCount = ${1:4};",
            "",
            "// Create MSAA texture",
            "MTLTextureDescriptor *msaaDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm",
            "                                                                                           width:${2:width}",
            "                                                                                          height:${3:height}",
            "                                                                                       mipmapped:NO];",
            "msaaDescriptor.textureType = MTLTextureType2DMultisample;",
            "msaaDescriptor.sampleCount = ${1};",
            "msaaDescriptor.usage = MTLTextureUsageRenderTarget;",
            "",
            "id<MTLTexture> msaaTexture = [device newTextureWithDescriptor:msaaDescriptor];"
        ],
        "description": "Metal MSAA (Multisample Anti-Aliasing) setup"
    },
    "Metal Argument Buffer": {
        "prefix": [
            "mtl_argument",
            "argument_buffer"
        ],
        "body": [
            "// Create argument encoder",
            "id<MTLArgumentEncoder> argumentEncoder = [function newArgumentEncoderWithBufferIndex:${1:0}];",
            "",
            "// Create argument buffer",
            "id<MTLBuffer> argumentBuffer = [device newBufferWithLength:argumentEncoder.encodedLength",
            "                                                    options:MTLResourceStorageModeShared];",
            "",
            "[argumentEncoder setArgumentBuffer:argumentBuffer offset:0];",
            "[argumentEncoder setBuffer:${2:dataBuffer} offset:0 atIndex:${3:0}];",
            "[argumentEncoder setTexture:${4:texture} atIndex:${5:0}];",
            "",
            "[encoder setVertexBuffer:argumentBuffer offset:0 atIndex:${1}];"
        ],
        "description": "Metal argument buffer for resource binding"
    },
    "MSL Compute Kernel": {
        "prefix": [
            "msl_compute",
            "compute_kernel_msl"
        ],
        "body": [
            "kernel void ${1:computeKernel}(",
            "    device float* input [[buffer(0)]],",
            "    device float* output [[buffer(1)]],",
            "    uint id [[thread_position_in_grid]])",
            "{",
            "    output[id] = ${2:input[id] * 2.0f};",
            "}"
        ],
        "description": "Metal Shading Language compute kernel"
    },
    "MSL Tessellation Vertex": {
        "prefix": [
            "msl_tess_vertex",
            "tessellation_vertex"
        ],
        "body": [
            "struct ControlPoint {",
            "    float4 position [[attribute(0)]];",
            "};",
            "",
            "struct PatchOut {",
            "    patch_control_point<ControlPoint> controlPoints;",
            "};",
            "",
            "[[patch(quad, 4)]]",
            "vertex PatchOut ${1:tessellationVertex}(",
            "    uint patchID [[patch_id]])",
            "{",
            "    PatchOut out;",
            "    $0",
            "    return out;",
            "}"
        ],
        "description": "Metal tessellation vertex function"
    },
    "MSL Vertex with Lighting": {
        "prefix": [
            "msl_lighting",
            "vertex_lighting"
        ],
        "body": [
            "struct VertexIn {",
            "    float3 position [[attribute(0)]];",
            "    float3 normal [[attribute(1)]];",
            "    float2 texCoord [[attribute(2)]];",
            "};",
            "",
            "struct VertexOut {",
            "    float4 position [[position]];",
            "    float3 worldNormal;",
            "    float3 worldPosition;",
            "    float2 texCoord;",
            "};",
            "",
            "struct Uniforms {",
            "    float4x4 modelMatrix;",
            "    float4x4 viewMatrix;",
            "    float4x4 projectionMatrix;",
            "    float3x3 normalMatrix;",
            "};",
            "",
            "vertex VertexOut ${1:vertexLighting}(",
            "    VertexIn in [[stage_in]],",
            "    constant Uniforms& uniforms [[buffer(1)]])",
            "{",
            "    VertexOut out;",
            "    ",
            "    float4 worldPos = uniforms.modelMatrix * float4(in.position, 1.0);",
            "    out.worldPosition = worldPos.xyz;",
            "    out.position = uniforms.projectionMatrix * uniforms.viewMatrix * worldPos;",
            "    out.worldNormal = uniforms.normalMatrix * in.normal;",
            "    out.texCoord = in.texCoord;",
            "    ",
            "    return out;",
            "}"
        ],
        "description": "MSL vertex shader with lighting support"
    }
}